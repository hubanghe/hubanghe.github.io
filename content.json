{"meta":{"title":"黄河滴滴的博客","subtitle":"在自由的阳光下各抒己见。","description":"福州大学2016级，兴趣于互联网各项技术，爱折腾，爱自由！","author":"黄河滴滴","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-09-14T14:38:37.757Z","updated":"2018-09-14T14:38:37.748Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-09-14T14:01:23.940Z","updated":"2018-09-14T14:01:23.931Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用THREE.js设计一款3D游戏","slug":"使用THREE-js设计一款3D游戏","date":"2018-10-05T12:21:34.000Z","updated":"2018-10-05T12:27:31.481Z","comments":true,"path":"2018/10/05/使用THREE-js设计一款3D游戏/","link":"","permalink":"http://yoursite.com/2018/10/05/使用THREE-js设计一款3D游戏/","excerpt":"","text":"使用THREE.js制作一款3D游戏本文是基于某位大神使用three.js设计游戏的学习心得与知识分享The Making of “The Aviator”: Animating a Basic 3D Scene with Three.js 前言这个学期选修了一门计算机图形学的课程，课程选用的教材是基于WebGL。在此之前我对计算机图形学是没有任何概念的，只知道如果想要设计一款游戏具有图形学的知识是很重要的。我从来就有一个念想就是制作一款游戏，因此我对这方面是很有兴趣的。老师推荐了一本入门教材《WebGL编程指南》，这本教材讲的很详细很适合入门使用，我花了大约一周的时间将这本书看完，对webgl的编程有了个大致的了解，当然真的只是粗粗入门。学习过程中又了解到three.js这个基于webgl的第三方3d图形库，看到了很多酷炫的3d游戏都使用了这个库，我决定下一步就是学习这个库的使用。我大概看了半本的《THREE.js开发指南》，这本书很系统的讲了这个第三方库，但是难免很枯燥，于是就找到了现在这个使用three.js设计游戏的这么一个小项目。 代码结构主函数由各种构件场景的函数组成，十分简洁123456789101112131415function init(event)&#123; createScene(); createLights(); createPlane(); createSea(); createSky(); document.addEventListener('mousemove', handleMouseMove, false); loop();//循环函数，用于最后每一个帧的重绘，实现动画效果&#125; 使用dat.gui图形界面动态的调整数据dat.gui是一个第三方的图形库，通过这个图形界面来调整数据真的很方便123456789//通过dat.gui来调整环境光var controls = new function () &#123;//声明一个控制对象 this.ambientLightColor = \"#dc8874\";&#125;//环境光的值可以是16进制的数值，如\"#ffffff\"，每次通过gui调整了color值都会触发下面的匿名函数从而调整环境光的颜色，环境光加入到场景中后每次渲染场景时都会使用最新的环境光颜色值，从而实现了使用gui调整环境光颜色的功能var gui = new dat.GUI;//创建gui对象gui.addColor(controls,'ambientLightColor').onChange(function (e) &#123; ambientLight.color = new THREE.Color(e);// &#125;); 当然可以添加更多的数据来进行动态调整，比如照相机的位置，各种颜色数值，等等。这是一个超级使用的功能。 一、搭建一个场景使用thre.js绘制3d图形最基本的就是需要一个场景，场景像一个容器，至少需要包括灯光，照相机和渲染器1234567891011121314151617181920212223function createScene()&#123; HEIGHT = window.innerHeight; WIDTH = window.innerWidth; scene = new THREE.Scene();//创建场景 scene.fog = new THREE.Fog(0xf7d9aa, 100,950);//使用雾化的效果 var axes = new THREE.AxisHelper(200);//场景中添加一个三维坐标系，便于观察图形的位置 scene.add(axes); aspectRatio = WIDTH / HEIGHT;//宽高比设置为窗口大小，避免图案的变形 fieldOfView = 50; nearPlane = 0.1; farPlane = 10000; camera = new THREE.PerspectiveCamera(fieldOfView,aspectRatio,nearPlane,farPlane);//使用一个透视相机使物体具有3d的效果 camera.position.x = 0;//相机的位置和视点将影响观察到的物体 camera.position.z = 200; camera.position.y = 100;//待优化 renderer = new THREE.WebGLRenderer(&#123; alpha: true, antialias: true &#125;);//声明一个webgl的渲染器，这个渲染器就如同html中的canvas renderer.setSize(WIDTH,HEIGHT); renderer.shadowMap.enabled = true; container = document.getElementById('world'); container.appendChild(renderer.domElement);//将这个渲染器加到html当中 二、添加灯光在three.js中添加灯光十分的简单，不同的灯光有不同的作用，比如环境光，点光源，聚光灯等等。这里用到了半球光，半球光其中设置的两个参数天空和地面的颜色可以使场景更加的真实。123456789101112131415161718function createLights()&#123; hemisphereLight = new THREE.HemisphereLight(0xbbbbbb,0x000000, .9); ambientLight = new THREE.AmbientLight(controls.ambientLightColor); shadowLight = new THREE.DirectionalLight(0xffffff, .9); shadowLight.castShadow = true; shadowLight.shadow.camera.left = -400; shadowLight.shadow.camera.right = 400; shadowLight.shadow.camera.top = 400; shadowLight.shadow.camera.bottom = -400; shadowLight.shadow.camera.near = 1; shadowLight.shadow.camera.far = 1000; shadowLight.shadow.mapSize.width = 2048; shadowLight.shadow.mapSize.height = 2048;//每次设置完灯光都需要把他添加到场景中 scene.add(hemisphereLight); scene.add(shadowLight); scene.add(ambientLight);&#125; 三、创造一片大海这里的大海是通过一个倒置的圆柱体来实现的，通过调整照相机的位置，并且配合旋转的动画，在半球光的照射下就如同一片汪洋。1234567891011121314151617181920Sea = function()&#123; var geom = new THREE.CylinderGeometry(600,600,800,40,10); geom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2)); var mat = new THREE.MeshPhongMaterial(&#123; color:Colors.blue, transparent:true, opacity:.6, shading:THREE.FlatShading, &#125;); this.mesh = new THREE.Mesh(geom, mat); this.mesh.receiveShadow = true;&#125;var sea;function createSea()&#123; sea = new Sea(); sea.mesh.position.y = -600; scene.add(sea.mesh);&#125; 四、简单又精致的天空我们使用几块大小不一的方块随机的堆叠在一起，它们就像云朵一样，很抽象派是吧！如果再把他们的位置随机的摆放，配合转动的动画，是不是更像了呢！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//构造一个云朵对象Cloud = function()&#123; this.mesh = new THREE.Object3D(); var geom = new THREE.BoxGeometry(20,20,20); var mat = new THREE.MeshPhongMaterial(&#123; color:Colors.white, &#125;); var nBlocs = 3+Math.floor(Math.random()*3); for(i=0;i&lt;nBlocs;i++)&#123; //实现位置随机，大小随机 var m = new THREE.Mesh(geom, mat); m.position.x = i*15; m.position.y =Math.random()*10; m.position.z = Math.random()*10; m.rotation.z = Math.random()*Math.PI*2; m.rotation.y = Math.random()*Math.PI*2; var s = .1 + Math.random()*.9; m.scale.set(s,s,s); m.castShadow = true; m.receiveShadow = true; this.mesh.add(m); &#125;&#125;Sky = function()&#123; this.mesh = new THREE.Object3D(); this.nClouds = 20; var stepAngle = Math.PI*2 / this.nClouds; for (var i=0;i&lt;this.nClouds;i++)&#123; var c = new Cloud(); var a = stepAngle*i; var h = 750 + Math.random()*200; c.mesh.position.y = Math.sin(a)*h; c.mesh.position.x = Math.cos(a)*h; c.mesh.rotation.z = - Math.PI/2+a; c.mesh.position.z = -50-Math.random()*400; var s = 1+Math.random()*2; c.mesh.scale.set(s,s,s); this.mesh.add(c.mesh); &#125;&#125;var sky;function createSky()&#123; sky = new Sky(); sky.mesh.position.y = -600; scene.add(sky.mesh);&#125; 五、设计一架超酷的飞机使用五个矩形打造一款飞机！这似乎听起来有点困难，但是这真的很有意思，配合不同的颜色，在螺旋桨的转动下，这款飞机真的很逼真！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var AirPlane = function() &#123; this.mesh = new THREE.Object3D(); // 这里要做的是一个驾驶舱 var geomCockpit = new THREE.BoxGeometry(80,50,50,1,1,1); var matCockpit = new THREE.MeshPhongMaterial(&#123;color:Colors.red, shading:THREE.FlatShading&#125;); geomCockpit.vertices[4].y-=10; geomCockpit.vertices[4].z+=20; geomCockpit.vertices[5].y-=10; geomCockpit.vertices[5].z-=20; geomCockpit.vertices[6].y+=20; geomCockpit.vertices[6].z+=20; geomCockpit.vertices[7].y+=20; geomCockpit.vertices[7].z-=20; var cockpit = new THREE.Mesh(geomCockpit, matCockpit); cockpit.castShadow = true; cockpit.receiveShadow = true; this.mesh.add(cockpit); // 还要有引擎盖 var geomEngine = new THREE.BoxGeometry(20,50,50,1,1,1); var matEngine = new THREE.MeshPhongMaterial(&#123;color:Colors.white, shading:THREE.FlatShading&#125;); var engine = new THREE.Mesh(geomEngine, matEngine); engine.position.x = 40; engine.castShadow = true; engine.receiveShadow = true; this.mesh.add(engine); // 做个尾巴吧 var geomTailPlane = new THREE.BoxGeometry(15,20,5,1,1,1); var matTailPlane = new THREE.MeshPhongMaterial(&#123;color:Colors.red, shading:THREE.FlatShading&#125;); var tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane); tailPlane.position.set(-35,25,0); tailPlane.castShadow = true; tailPlane.receiveShadow = true; this.mesh.add(tailPlane); // 机翼当然少不了，用长长的矩形穿过机身，多么美妙！ var geomSideWing = new THREE.BoxGeometry(40,8,150,1,1,1); var matSideWing = new THREE.MeshPhongMaterial(&#123;color:Colors.red, shading:THREE.FlatShading&#125;); var sideWing = new THREE.Mesh(geomSideWing, matSideWing); sideWing.castShadow = true; sideWing.receiveShadow = true; this.mesh.add(sideWing); // 飞机前端旋转的螺旋桨 var geomPropeller = new THREE.BoxGeometry(20,10,10,1,1,1); var matPropeller = new THREE.MeshPhongMaterial(&#123;color:Colors.brown, shading:THREE.FlatShading&#125;); this.propeller = new THREE.Mesh(geomPropeller, matPropeller); this.propeller.castShadow = true; this.propeller.receiveShadow = true; // 螺旋桨 var geomBlade = new THREE.BoxGeometry(1,100,20,1,1,1); var matBlade = new THREE.MeshPhongMaterial(&#123;color:Colors.brownDark, shading:THREE.FlatShading&#125;); var blade = new THREE.Mesh(geomBlade, matBlade); blade.position.set(8,0,0); blade.castShadow = true; blade.receiveShadow = true; this.propeller.add(blade); this.propeller.position.set(50,0,0); this.mesh.add(this.propeller);&#125;;var airplane;function createPlane()&#123; airplane = new AirPlane(); airplane.mesh.scale.set(.25,.25,.25); airplane.mesh.position.y = 100; scene.add(airplane.mesh);&#125; 好了，伙计！现在我们的场景中有了灯光，大海，天空还有飞机，但是，似乎还少了什么。对的，我们要操控这个飞机！ 六、控制我们的飞机飞机能跟随鼠标移动的轨迹，为了做到更完美，当飞机上升和下降时，应该要有旋转的感觉！12345678910111213141516171819202122232425262728293031function handleMouseMove(event) &#123; // 我们要把鼠标的坐标值转换成webgl系统中规格化的数值，从-1到1 // 这种转换很简单的伙计！tx = (x-width/2)/(width/2) var tx = -1 + (event.clientX / WIDTH)*2; // y轴在窗口坐标系和webg坐标系的方向是相反的，因此我们把他逆一下就可以 var ty = 1 - (event.clientY / HEIGHT)*2; mousePos = &#123;x:tx, y:ty&#125;;&#125;function updatePlane()&#123; var targetY = 100+mousePos.y*75;//控制飞机在y轴25到175的位置 var targetX = mousePos.x*195;//控制飞机在x轴-195到195的位置 // 每一帧移动飞机移动的距离，使飞机最终到达鼠标的位置，这样制造出飞机缓缓飞向指定位置的效果，而不会显得很突兀。 airplane.mesh.position.y += (targetY-airplane.mesh.position.y)*0.1; airplane.mesh.position.x += (targetX-airplane.mesh.position.x)*0.5; // 通过剩余距离的长度来计算旋转地幅度，这样飞机如果一次性移动的距离很多相应的旋转幅度就越大，与真实的情况也符合，使动画更加真实。 airplane.mesh.rotation.z = (targetY-airplane.mesh.position.y)*0.0256; airplane.mesh.rotation.x = (airplane.mesh.position.y-targetY)*0.0256; airplane.propeller.rotation.x += 0.3;&#125; 七、让画面动起来、实现动画的本质就是每一帧改变相应的参数，不断的渲染，使人眼感觉画面在运动1234567891011121314function loop()&#123; airplane.propeller.rotation.x += 0.3; sea.mesh.rotation.z += .005; sky.mesh.rotation.z += .01; updatePlane(); airplane.pilot.updateHairs(); // 渲染 renderer.render(scene, camera); // 再次调用 requestAnimationFrame(loop);&#125; 最后看看我们的demo吧！ enter image description here 当然还有更多的创意还可以实现，不是吗？","categories":[],"tags":[{"name":"THREE.js","slug":"THREE-js","permalink":"http://yoursite.com/tags/THREE-js/"},{"name":"WebGL","slug":"WebGL","permalink":"http://yoursite.com/tags/WebGL/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"}]},{"title":"谈谈hexo的使用","slug":"谈谈hexo的使用","date":"2018-09-21T09:37:51.000Z","updated":"2018-09-24T09:59:58.789Z","comments":true,"path":"2018/09/21/谈谈hexo的使用/","link":"","permalink":"http://yoursite.com/2018/09/21/谈谈hexo的使用/","excerpt":"","text":"序言今年有了写博客的念头，一来是为了巩固学习，把学习知识的过程和遇到的难点都记录下来，二来也是最重要的，就是为了装x，毕竟每个大佬都要有属于自己的技术博客嘛。其实我是很早就有建个网站的打算的，但是苦于不知道建什么类型的网站，因此这个念想被搁置了很久，想来估计也有好几年了。最近寻思着可以建一个属于自己的博客网站，逼格满满嘛。github上提供一个可存放静态页面的主机，把吃灰许久的域名用上，网上一键式的建站框架一跑（对，说的就是hexo），倒腾个博客网站也不算什么难事，不费事不费钱的。 hexo是什么东西看看官方的解释哈 hexo是一个快速、简介且高效的博客框架，让几百个页面在几秒内瞬间完成渲染。 听这个说法，是个神器。然后呢，自然是去深入的了解这么个神器，hexo功能很强大，建博客网站很简便，网络上大神的主题很多，选择一个套 在自己的博客上简直不要太舒服。 hexo使用心得hexo怎么安装啊，安装在哪里啊。。。。我可不想把这么low的东西写在博客里头，这种最基本的东西直接谷歌搜索hexo的官方文档就好了，写的很详细，基本上就是一键搭建。博客里还是记录点让我感到头疼的东东。 hexo文件结构把hexo初始化到自己指定的那个文件夹后，里头会自动生成一些东西，结构如下 .|—— _config.yml|—— package.json|—— scaffolds|—— source|&nbsp;&nbsp;&nbsp;&nbsp; |—— _drafts|&nbsp;&nbsp;&nbsp;&nbsp; |—— _posts|——themes 网站的配置信息都保存在config这个文件里头，里面英文单词的意思也算好懂，搭配注释看看问题也不大。但是配置过程有个小坑不得不提，那就是修改的配置信息项，就是那种键值对，在值前面冒号后面记得加上一个空格。package这个玩意我不懂，也没用到。scaffolds这个文件是模版文件夹，在写文章时hexo会根据这个来新建文章，但没整明白是怎么一回事。 来看看source文件夹，写文章打交道最多的就是这个文件夹了,里头有两个子文件夹，分别是draft和post。很显然一个是打草稿的，一个写文章的。要写文章可以通过gitbash输入命令，也可以直接在post文件夹新建md文件，我是选择直接在那新建文件，舒服啊！ 还有一个很重要的文件夹就是themes了，从网络上下载的主题一般都放在这，要配置主题也是在这个文件夹里找到相应的主题配置文件。不同主题的配置方法有差异，毕竟主题都有自己的特色，但是主题的发布者一般会有关于主题配置的详细介绍。 我觉得要想熟悉并使用好hexo这个博客框架，还是很有必要搞清楚这几个文件夹各自的作用的，否则用起来就是云里雾里的。接下来重点讲下hexo是怎么工作的（不涉及任何原理，我也不懂），每当我们写完一篇文章并且借助hexo生成静态页面时，就会生成一个public文件夹，里头存放了所有有关这个静态页面的文件。hexo生成这些文件的原材料来源于souce文件夹，也就是这个源文件夹，里头包含文章的md文件，当然也可以在里头放一些其他东西，比如图片，音乐。hexo生成时就会把这些东西全部搬到public这个文件夹，并覆盖原先的。 我把博客建立在github提供的免费空间上，github要求根目录包含一个cname的文件，但是使用hexo的默认方式写文章的话，每次部署后github上的cname文件都会消失，这很烦人。由于我的source文件夹里头没有cname这个文件，每次生成并且部署后自然也没有。那么一劳永逸的方法就是直接把这个文件放在本地的source文件夹中，这样每次部署后cname文件就不会消失了。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"学用md写文章","slug":"学用md写文章","date":"2018-09-13T12:03:18.000Z","updated":"2018-09-16T08:32:21.077Z","comments":true,"path":"2018/09/13/学用md写文章/","link":"","permalink":"http://yoursite.com/2018/09/13/学用md写文章/","excerpt":"","text":"序言 没写过博客，文采也差，逻辑又混乱，故写出来的文章肯定不优秀。我写的不是文章，我写的都是口水文，用我的逻辑将我的体会写给我看。 这真是个怪想法今年迈入大三，明年步入打工生涯，听闻是个大佬都要有个自己的博客，无奈不屑寄居csdn，萌生建站学学大佬，选择优秀hexo，不巧每篇博文要求md，苦逼今日入门md flag在此竖起本人技术捉急，为人内向怕事，但心中却时常波澜壮阔。本博客的博文是实打实的口水文，面向对象为博主，不接受任何吐槽，甚至访问。 言简意赅写文章md的语法谷歌搜索一大堆，想要全部记下是有一定难度的，毕竟有那么多花里胡哨的技巧。利用其中的基础语法写一篇贵方的博文并不是什么很费事的事，md语法结合对html解释语言的理解可以发现md就是将html的语言进行了自动的转换，让作者写作更加轻松。 在我看来，一篇博文无非由标题和段落组成。标题由’#’的个数决定，从h1一直可以设置到h6。在md文件中不加修饰的文字都会被段落标签所包括，也就是说随意的写作文字即写的是一个段落，这是多么愉快的一件事啊！如何实现分段呢？十分简单，在一段结束后，空一行再起另一段，实在是很符合程序员的逻辑。 md中不得不提的是引用功能，通过”&gt;”就可以快捷的使用，同样引用也是分级的，由”&gt;”的个数决定级别。”&gt;”后面的文字会包括在一个块标签、p标签。在引用块中的书写若需多段文字，分段的方式也是相同的，不同段落使用空白行分隔即可，但应注意的一点是，同一级块文字的最左侧应保持有”&gt;”，也许仅仅是一个空白行，这很美观，而且是一个良好的习惯。 以上是我觉得写一篇博文需要用到的几个语法，这些足以让一篇有内容的博文在网页上呈现的美观且易读。关于插入链接，可以看看这个:黄河滴滴的博客的github地址 md同样是支持插入图片的，但我并不喜欢他们，文字在我的脑海中跳舞，图片只会让我呆滞。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"口水论代理","slug":"口水论代理","date":"2018-09-12T15:51:15.000Z","updated":"2018-09-12T15:51:15.078Z","comments":true,"path":"2018/09/12/口水论代理/","link":"","permalink":"http://yoursite.com/2018/09/12/口水论代理/","excerpt":"","text":"","categories":[],"tags":[]}]}